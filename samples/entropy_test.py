#!/usr/bin/python

__description__ = "Test to identify autogenerated text."
__author__ = "candycanejane"
__copyright__ = "Copyright 2016"
__email__ = "bumbleb33tuna@gmail.com"

import os
import sys
import re
import logging

"""
Test 1 - "Scrabble score"
Based on the idea that certain letters appear more frequently in the English language, and a program that autogenerates alphanumeric text will disregard this pattern. We give each letter in a module name a score.

	Example 1: BwHrfGYabsRuai receives a "Scrabble" score of 31. 
	Example 2: modMaintenance receives a "Scrabble" score of 21.

Test 2 - "CamelCase"
Based on the idea that autogenerated module names do not use proper CamelCase, and a majority of legit functions do. Our test splits a name on capitals and tests to see if those words are in the dictionary, as legitimate function names often describe their functionality. Early tests detected false positives with long module names that clearly were not obfuscated. This test reduces the chance of falsing on this type of naming convention.

	Example 1: mSZhlqIzaAXnKs contains capitals, but this is obviously not CamelCase. 
	Example 2: modImportExport becomes ['mod','Import','Export']; "import" and "export" appear in the dictionary so, we'll reduce the overall score by 20.

Test 3 - "Misplaced numbers"
Our review of function names identified that numbers are commonly used at the end (ie. Module1, Sheet22). Autogenerated alphanumeric names will have numbers all over the place. We strip off the end numbers and penalize any other numbers found.

	Example 1: a0x285S contains three "misplaced numbers", and we add 5 to the score for each one.
	Example 2: frmProgressBar1 is ok (there are some false positives that we add to a whitelist)

Test 4 - "Lowercase"
Our review of obfuscated names has identified some autogenerated text that is all lowercase and thus bypasses many of our case-sensitive tests. While there are some legitimate names that use all lowercase (see exclusion list below), most use CamelCase. All lowercase names are checked for dictionary words or given a penalty score.

	Example 1: truyiqwnd scores 25 by itself but is not enough to pass our tests. With penalty score, it passes the threshold for obfuscation detection.
	Example 2: pwmandswitchingwaveforms flags as obfuscated. There's no good way to exclude this false positive.

Test 5 - "Too many capitals"
In genuine CamelCase, the percentage of capital letters in the whole word is generally less than 33%. We want to identify autogenerated text that indiscriminately uses capital letters and increase the score for those. We purposefully exclude 100% because there were too many falses.

	Example 1: nQPLoq has 3 capitals to 6 letters, meaning 50% are capitals. This would increase the overall score.
	Example 2: modModificationHistory has 2 capitals to 22 letters or 9% capitals.

Test 6 - "Dictionary words" - DISABLED FOR NOW
 Autogenerated functions are gibberish or we've noticed they use random words (or even made up words) from the dictionary. We'd like to identify this type of "dictionary" obfuscation. This will NOT work w/ the general function search below, only module name hits.

 	Example 1: crystallized is clearly not a normal function name. We automatically flag these.
 	Example 2: sort kept triggering falses so it was added to our whitelist.
 	Example 3: Title is checked for "titlecase" and excluded due to the number of falses.

"""

# basic logging for local testing
logging.basicConfig(format='%(asctime)s %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p', filename='entropy_test9.log', filemode='w', level=logging.INFO)
log = logging.getLogger('entropy_test')


# search text in macro area (this will save us from parsing the whole file)
ROOT = re.compile(r'R\x00o\x00o\x00t\x00 \x00E\x00n\x00t\x00r\x00y\x00')
# hits of 5 letters or more to reduce falses (there's a lot of junk at the end of a file)
FUNC = re.compile(r'\x00([\w\d]{5,30})')
# regex for splitting a string on capitals
CAPS = re.compile(r'[A-Z][a-z]+')

# "Scrabble" dictionary lookup
alpha = {'a': 1,
		'b': 3,
		'c': 3,
		'd': 2,
		'e': 1,
		'f': 4,
		'g': 2,
		'h': 4,
		'i': 1,
		'j': 8,
		'k': 5,
		'l': 1,
		'm': 3,
		'n': 1,
		'o': 1,
		'p': 3,
		'q': 10,
		'r': 1,
		's': 1,
		't': 1,
		'u': 1,
		'v': 4,
		'w': 4,
		'x': 8,
		'y': 4,
		'z': 10
		}

# build dictionary lookup using local wordlist file; only four-letter words or greater
try:
	with open('/usr/share/dict/words','rU') as f:
		all_text = f.read()
		words = all_text.split('\n')
		f_words = [word.lower() for word in words if len(word) > 2]
		# build alphabet dictionary w/ default score
		alphabet = dict.fromkeys(f_words,25)
	f.close()
except Exception as e:
	log.exception("Error parsing dictionary file. %s", e)


# calculate "Scrabble" score for module name based on frequency of letters in English dictionary; the goal is to identify randomly generated module names
def score_letters(func):
	score = 0
	lol = list(func.lower())
	for letter in lol:
		if letter.isalpha():
			# get score from alpha dictionary
			score += alpha[letter]
	return score

# split function on capitals and check for dictionary words (as would normally appear in legit macros)
def score_camelcase(func):
	score = 0
	words = CAPS.findall(func)
	# we don't need to look up single letters in the dictionary (ie. 'A') so we filter this list
	f_words = [word.lower() for word in words if len(word) > 2]
	if f_words:
		for word in f_words:
			length = len(word)
			for i in range(length+1):
				if word[:i] in alphabet:
					# the goal is to reduce the score "penalty" incurred from long, CamelCase function names
					score -= 10
					break
	return score

# score module name based on random numbers present
def score_nums(func):
	score = 0
	func = func.rstrip('0123456789')
	lol = list(func)
	for letter in lol:
		# non-ending digits receive a "penalty" score of 5
		if letter.isdigit():
			score += 5
	return score

# identify all lowercase functions vs. CamelCase; conduct front/back dictionary lookups to reduce falses
def score_lower_upper(func):
	score = 0
	if func.islower() or func.isupper():
		length = len(func)
		func = func.lower()
		# strip off end characters and lookup until there's a match
		for i in range(length+1):
			if func[-i:] in alphabet:
				score -= 10
				break
		# strip off beginning characters and lookup until there's a match
		for i in range(length+1):
			if func[:i] in alphabet:
				score -= 10
				break
		# keep default penalty for all lowercase
		if score < 0:
			return score
		elif func.islower():
			score += 5
	return score


# identify Non-CamelCase by percentage of capitals compared to the total number of letters
def score_caps(func):
	score = 0
	cap_cnt = 0
	length = len(func)
	lol = list(func)
	for letter in lol:
		# count number of capitals
		if letter.isupper():
			cap_cnt += 1
	# if percentage exceeds 39%, increase the score
	#TO DO: I believe this calculation is only accurate to one decimal place though. Does anyone know how to fix?
	percent = float(cap_cnt)/float(length)
	if (percent > 0.39) and (percent < 1.00):
		score += 7
	return score

# used to identify random dictionary words used in module names
def score_dict(func):
	score = 0
	if not func.istitle():
		func = func.lower()
		if func in alphabet:
			score += alphabet[func]
	return score 

# if just uppercase and numbers, likely bad regex match
def hex_only(func):
	lol = list(func)
	hex = ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F']
	for letter in lol:
		if letter not in hex:
			return False
	return True

# filter hits 
def filter_hits(listofHits):
	# filter out hits w/ special characters (generally those names are ok and generate falses); hits w/ three characters or less; common name hits or those triggering falses
	hits = [hit for hit in listofHits if (not hit[0].isdigit() and hit.isalnum() and len(hit) > 3 and hit not in ['ThisDocument','Module1','Module2','Module3','Module4','Module5','Module6','Module7','Module8','Module9','Module10','Module11','UserForm1','UserForm2','UserForm3','Sheet1','Sheet2','Sheet3','Sheet4','Sheet5','Sheet6','Sheet7','Sheet8','Sheet9','Sheet10','Sheet11','ffffff','modXlat4TechSpecs','modXlat3TandC','STDXXXXX','STDPDXXXXX','STDXXXXX5','STDXXXXXC','STDPDXXXXXC','chkOrganizationalHierarchy'])]
	hits2 = [hit for hit in hits if not hex_only(hit)]
	return hits2

# main function to detect if file contains obfuscated text; if # hits more than 10, return True
def isObfuscated(rawtext):
	obf_func_hits = []

	# search text for "Root Entry" and start next search there so we bypass main text of document
	root_hit = ROOT.search(rawtext)
	if root_hit:
		loc = root_hit.end()
		# start function name search here
		func_hits = FUNC.findall(rawtext,pos=loc)
		u_hits = set(func_hits)
		f_hits = filter_hits(u_hits)
		if f_hits:
			for hit in f_hits:
				fscore = 0
				fscore += score_letters(hit)
				fscore += score_camelcase(hit)
				fscore += score_nums(hit)
				fscore += score_lower_upper(hit)
				fscore += score_caps(hit)
				if fscore > 29:
					obf_func_hits.append(hit)
					#print "Hit: {0} Score: {1}".format(hit,fscore)
		#print obf_func_hits

	# due to false positives and given that a truly obfuscated file contains dozens of obfuscated lines, we flag the file if there are more than 10 names
	if len(obf_func_hits) > 10:
		log.info("Obfuscated functions: %s",','.join(obf_func_hits))
		return (True, ','.join(obf_func_hits))
	else:
		return (False, '')

def main(argv):
	# check utilization
	nargs = len(argv)
	if nargs != 2:
		print "Usage: %s folder" % os.path.basename(argv[0])
		sys.exit()
	else:
		folder_path = argv[1]

	if not os.path.isdir(folder_path):
		print "Provide the full path to the folder"
		sys.exit()
	
	# search folder for files containing obfuscated text
	for root, dirs, files in os.walk(folder_path):
		for file in files:
			path = os.path.join(root, file)
			fn = path.strip()
			try:
				with open(path, 'r') as rawfile:
					text = rawfile.read()
					(result, text) = isObfuscated(text)
					log.info("File: %s Obfuscated: %s Text: %s", file_path, result, text)
				rawfile.close()

			except Exception as e:
				log.exception("Error parsing file. %s", e)

if __name__ == '__main__':
	main(sys.argv)